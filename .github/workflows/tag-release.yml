name: Tag Release

on:
  push:
    tags:
      - "v*.*.*" # Trigger on semantic version tags (e.g., v1.0.0, v2.1.3)

permissions:
  contents: write

jobs:
  validate-tag:
    name: Validate Version Tag
    runs-on: ubuntu-latest
    outputs:
      version: ${{ steps.validate.outputs.version }}
      is_prerelease: ${{ steps.validate.outputs.is_prerelease }}

    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Validate semantic version tag
        id: validate
        run: |
          TAG_NAME=${GITHUB_REF#refs/tags/}
          echo "Validating tag: $TAG_NAME"

          # Validate semantic version format (v1.2.3 or v1.2.3-beta.1)
          if [[ ! $TAG_NAME =~ ^v[0-9]+\.[0-9]+\.[0-9]+(-[a-zA-Z0-9.]+)?$ ]]; then
            echo "‚ùå Invalid version tag format: $TAG_NAME"
            echo "Expected format: v1.2.3 or v1.2.3-beta.1"
            exit 1
          fi

          echo "‚úì Valid semantic version tag"
          echo "version=$TAG_NAME" >> $GITHUB_OUTPUT

          # Check if this is a pre-release
          if [[ $TAG_NAME =~ -[a-zA-Z] ]]; then
            echo "is_prerelease=true" >> $GITHUB_OUTPUT
            echo "This is a pre-release version"
          else
            echo "is_prerelease=false" >> $GITHUB_OUTPUT
            echo "This is a stable release"
          fi

  create-release:
    name: Create GitHub Release
    runs-on: ubuntu-latest
    needs: validate-tag
    outputs:
      release_id: ${{ steps.create_release.outputs.id }}
      upload_url: ${{ steps.create_release.outputs.upload_url }}

    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Generate release notes
        id: release_notes
        run: |
          VERSION="${{ needs.validate-tag.outputs.version }}"

          # Get previous tag for comparison
          PREV_TAG=$(git describe --tags --abbrev=0 HEAD^ 2>/dev/null || echo "")

          if [ -z "$PREV_TAG" ]; then
            echo "## Initial Release" > release_notes.md
            echo "" >> release_notes.md
            echo "This is the first release of asyncapi-doc." >> release_notes.md
          else
            echo "## What's Changed" > release_notes.md
            echo "" >> release_notes.md

            # Generate changelog from commits
            git log --pretty=format:"- %s (%h)" ${PREV_TAG}..HEAD >> release_notes.md

            echo "" >> release_notes.md
            echo "" >> release_notes.md
            echo "**Full Changelog**: https://github.com/${{ github.repository }}/compare/${PREV_TAG}...${VERSION}" >> release_notes.md
          fi

          echo "" >> release_notes.md
          echo "---" >> release_notes.md
          echo "" >> release_notes.md
          echo "üì¶ **Binaries will be uploaded shortly...**" >> release_notes.md

      - name: Create GitHub Release
        id: create_release
        uses: actions/github-script@v8
        with:
          script: |
            const fs = require('fs');
            const releaseNotes = fs.readFileSync('release_notes.md', 'utf8');

            const response = await github.rest.repos.createRelease({
              owner: context.repo.owner,
              repo: context.repo.repo,
              tag_name: '${{ needs.validate-tag.outputs.version }}',
              name: '${{ needs.validate-tag.outputs.version }}',
              body: releaseNotes,
              draft: false,
              prerelease: ${{ needs.validate-tag.outputs.is_prerelease == 'true' }}
            });

            core.setOutput('id', response.data.id);
            core.setOutput('upload_url', response.data.upload_url);

            console.log('‚úì Release created:', response.data.html_url);

  build:
    name: Build and Upload Release Assets
    runs-on: ubuntu-latest
    needs: [validate-tag, create-release]

    strategy:
      matrix:
        include:
          - goos: linux
            goarch: amd64
          - goos: linux
            goarch: arm64
          - goos: darwin
            goarch: amd64
          - goos: darwin
            goarch: arm64
          - goos: windows
            goarch: amd64
          - goos: windows
            goarch: arm64

    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Set up Go
        uses: actions/setup-go@v5
        with:
          go-version: "1.23"
          cache: true

      - name: Build binary
        env:
          GOOS: ${{ matrix.goos }}
          GOARCH: ${{ matrix.goarch }}
          CGO_ENABLED: 0
        run: |
          VERSION="${{ needs.validate-tag.outputs.version }}"
          BUILD_TIME=$(date -u '+%Y-%m-%d_%H:%M:%S')
          GIT_COMMIT=$(git rev-parse --short HEAD)

          BINARY_NAME="asyncapi-doc"
          if [ "${{ matrix.goos }}" = "windows" ]; then
            BINARY_NAME="${BINARY_NAME}.exe"
          fi

          LDFLAGS="-s -w -X main.Version=${VERSION} -X main.BuildTime=${BUILD_TIME} -X main.GitCommit=${GIT_COMMIT}"

          go build -ldflags "${LDFLAGS}" -o "${BINARY_NAME}" ./cmd/asyncapi-doc

          # Rename binary to include version and platform
          FINAL_NAME="asyncapi-doc-${VERSION}-${{ matrix.goos }}-${{ matrix.goarch }}"
          if [ "${{ matrix.goos }}" = "windows" ]; then
            FINAL_NAME="${FINAL_NAME}.exe"
          fi

          mv "${BINARY_NAME}" "${FINAL_NAME}"
          echo "binary=${FINAL_NAME}" >> $GITHUB_ENV

      - name: Smoke test binary
        run: |
          BINARY_FILE="${{ env.binary }}"

          echo "Running smoke tests on ${BINARY_FILE} (${{ matrix.goos }}-${{ matrix.goarch }})..."

          # Test 1: Check if binary exists
          if [ ! -f "${BINARY_FILE}" ]; then
            echo "‚ùå Binary not found: ${BINARY_FILE}"
            exit 1
          fi

          echo "‚úì Binary file exists"

          # Test 2: Check binary size (should be > 1MB for Go binaries)
          SIZE=$(stat -c%s "${BINARY_FILE}" 2>/dev/null || stat -f%z "${BINARY_FILE}" 2>/dev/null || echo "0")
          if [ "$SIZE" -lt 1000000 ]; then
            echo "‚ùå Binary size too small: ${SIZE} bytes"
            exit 1
          fi

          echo "‚úì Binary size is valid: ${SIZE} bytes"

          # Test 3: Verify it's actually a binary file
          if file "${BINARY_FILE}" | grep -q "executable"; then
            echo "‚úì File is an executable binary"
          elif file "${BINARY_FILE}" | grep -q "PE32"; then
            echo "‚úì File is a Windows executable"
          else
            echo "‚ö† Warning: Unexpected file type"
            file "${BINARY_FILE}"
          fi

          # Test 4: Only run the binary on native platform (Linux amd64)
          # Skip execution for cross-compiled binaries (macOS, Windows, ARM)
          RUNNER_OS="linux"
          RUNNER_ARCH="amd64"

          if [ "${{ matrix.goos }}" = "$RUNNER_OS" ] && [ "${{ matrix.goarch }}" = "$RUNNER_ARCH" ]; then
            chmod +x "${BINARY_FILE}"
            echo "Testing version command..."
            ./${BINARY_FILE} version || {
              echo "‚ùå Version command failed"
              exit 1
            }

            echo "Testing help output..."
            ./${BINARY_FILE} 2>&1 | grep -q "asyncapi-doc" || {
              echo "‚ùå Help output validation failed"
              exit 1
            }

            echo "‚úì Binary execution tests passed"
          else
            echo "‚è≠ Skipping execution tests for ${{ matrix.goos }}-${{ matrix.goarch }} (cross-compiled, runner is ${RUNNER_OS}-${RUNNER_ARCH})"
          fi

          echo "‚úì All smoke tests passed for ${{ matrix.goos }}-${{ matrix.goarch }}"

      - name: Upload release asset
        uses: actions/upload-release-asset@v1
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        with:
          upload_url: ${{ needs.create-release.outputs.upload_url }}
          asset_path: ./${{ env.binary }}
          asset_name: ${{ env.binary }}
          asset_content_type: application/octet-stream
