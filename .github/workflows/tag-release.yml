name: Tag Release

on:
  push:
    tags:
      - "v*.*.*" # Trigger on semantic version tags (e.g., v1.0.0, v2.1.3)

permissions:
  contents: write

jobs:
  validate-tag:
    name: Validate Version Tag
    runs-on: ubuntu-latest
    outputs:
      version: ${{ steps.validate.outputs.version }}
      is_prerelease: ${{ steps.validate.outputs.is_prerelease }}

    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Validate semantic version tag
        id: validate
        run: |
          TAG_NAME=${GITHUB_REF#refs/tags/}
          echo "Validating tag: $TAG_NAME"

          # Validate semantic version format (v1.2.3 or v1.2.3-beta.1)
          if [[ ! $TAG_NAME =~ ^v[0-9]+\.[0-9]+\.[0-9]+(-[a-zA-Z0-9.]+)?$ ]]; then
            echo "âŒ Invalid version tag format: $TAG_NAME"
            echo "Expected format: v1.2.3 or v1.2.3-beta.1"
            exit 1
          fi

          echo "âœ“ Valid semantic version tag"
          echo "version=$TAG_NAME" >> $GITHUB_OUTPUT

          # Check if this is a pre-release
          if [[ $TAG_NAME =~ -[a-zA-Z] ]]; then
            echo "is_prerelease=true" >> $GITHUB_OUTPUT
            echo "This is a pre-release version"
          else
            echo "is_prerelease=false" >> $GITHUB_OUTPUT
            echo "This is a stable release"
          fi

  create-release:
    name: Create GitHub Release
    runs-on: ubuntu-latest
    needs: validate-tag
    outputs:
      release_id: ${{ steps.create_release.outputs.id }}
      upload_url: ${{ steps.create_release.outputs.upload_url }}

    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Generate release notes
        id: release_notes
        run: |
          VERSION="${{ needs.validate-tag.outputs.version }}"

          # Get previous tag for comparison
          PREV_TAG=$(git describe --tags --abbrev=0 HEAD^ 2>/dev/null || echo "")

          if [ -z "$PREV_TAG" ]; then
            echo "## Initial Release" > release_notes.md
            echo "" >> release_notes.md
            echo "This is the first release of asyncapi-doc." >> release_notes.md
          else
            echo "## What's Changed" > release_notes.md
            echo "" >> release_notes.md

            # Generate changelog from commits
            git log --pretty=format:"- %s (%h)" ${PREV_TAG}..HEAD >> release_notes.md

            echo "" >> release_notes.md
            echo "" >> release_notes.md
            echo "**Full Changelog**: https://github.com/${{ github.repository }}/compare/${PREV_TAG}...${VERSION}" >> release_notes.md
          fi

          echo "" >> release_notes.md
          echo "---" >> release_notes.md
          echo "" >> release_notes.md
          echo "ðŸ“¦ **Binaries will be uploaded shortly...**" >> release_notes.md

      - name: Create GitHub Release
        id: create_release
        uses: actions/github-script@v7
        with:
          script: |
            const fs = require('fs');
            const releaseNotes = fs.readFileSync('release_notes.md', 'utf8');

            const response = await github.rest.repos.createRelease({
              owner: context.repo.owner,
              repo: context.repo.repo,
              tag_name: '${{ needs.validate-tag.outputs.version }}',
              name: '${{ needs.validate-tag.outputs.version }}',
              body: releaseNotes,
              draft: false,
              prerelease: ${{ needs.validate-tag.outputs.is_prerelease == 'true' }}
            });

            core.setOutput('id', response.data.id);
            core.setOutput('upload_url', response.data.upload_url);

            console.log('âœ“ Release created:', response.data.html_url);

  build:
    name: Build and Upload Release Assets
    runs-on: ubuntu-latest
    needs: [validate-tag, create-release]

    strategy:
      matrix:
        include:
          - goos: linux
            goarch: amd64
          - goos: linux
            goarch: arm64
          - goos: darwin
            goarch: amd64
          - goos: darwin
            goarch: arm64
          - goos: windows
            goarch: amd64
          - goos: windows
            goarch: arm64

    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Set up Go
        uses: actions/setup-go@v5
        with:
          go-version: "1.23"
          cache: true

      - name: Build binary
        env:
          GOOS: ${{ matrix.goos }}
          GOARCH: ${{ matrix.goarch }}
          CGO_ENABLED: 0
        run: |
          VERSION="${{ needs.validate-tag.outputs.version }}"
          BUILD_TIME=$(date -u '+%Y-%m-%d_%H:%M:%S')
          GIT_COMMIT=$(git rev-parse --short HEAD)

          BINARY_NAME="asyncapi-doc"
          if [ "${{ matrix.goos }}" = "windows" ]; then
            BINARY_NAME="${BINARY_NAME}.exe"
          fi

          LDFLAGS="-s -w -X main.Version=${VERSION} -X main.BuildTime=${BUILD_TIME} -X main.GitCommit=${GIT_COMMIT}"

          go build -ldflags "${LDFLAGS}" -o "${BINARY_NAME}" ./cmd/asyncapi-doc

          # Create archive
          ARCHIVE_NAME="asyncapi-doc-${VERSION}-${{ matrix.goos }}-${{ matrix.goarch }}"
          if [ "${{ matrix.goos }}" = "windows" ]; then
            zip "${ARCHIVE_NAME}.zip" "${BINARY_NAME}"
            echo "archive=${ARCHIVE_NAME}.zip" >> $GITHUB_ENV
          else
            tar czf "${ARCHIVE_NAME}.tar.gz" "${BINARY_NAME}"
            echo "archive=${ARCHIVE_NAME}.tar.gz" >> $GITHUB_ENV
          fi

      - name: Smoke test binary
        run: |
          BINARY_NAME="asyncapi-doc"
          if [ "${{ matrix.goos }}" = "windows" ]; then
            BINARY_NAME="${BINARY_NAME}.exe"
          fi

          echo "Running smoke tests on ${BINARY_NAME} (${{ matrix.goos }}-${{ matrix.goarch }})..."

          # Test 1: Check if binary exists
          if [ ! -f "${BINARY_NAME}" ]; then
            echo "âŒ Binary not found: ${BINARY_NAME}"
            exit 1
          fi

          echo "âœ“ Binary file exists"

          # Test 2: Check binary size (should be > 1MB for Go binaries)
          SIZE=$(stat -c%s "${BINARY_NAME}" 2>/dev/null || stat -f%z "${BINARY_NAME}" 2>/dev/null || echo "0")
          if [ "$SIZE" -lt 1000000 ]; then
            echo "âŒ Binary size too small: ${SIZE} bytes"
            exit 1
          fi

          echo "âœ“ Binary size is valid: ${SIZE} bytes"

          # Test 3: Verify it's actually a binary file
          if file "${BINARY_NAME}" | grep -q "executable"; then
            echo "âœ“ File is an executable binary"
          elif file "${BINARY_NAME}" | grep -q "PE32"; then
            echo "âœ“ File is a Windows executable"
          else
            echo "âš  Warning: Unexpected file type"
            file "${BINARY_NAME}"
          fi

          # Test 4: Only run the binary on matching platform
          if [ "${{ matrix.goos }}" = "linux" ] && [ "${{ matrix.goarch }}" = "amd64" ]; then
            chmod +x "${BINARY_NAME}"
            echo "Testing version command..."
            ./${BINARY_NAME} version || {
              echo "âŒ Version command failed"
              exit 1
            }

            echo "Testing help output..."
            ./${BINARY_NAME} 2>&1 | grep -q "asyncapi-doc" || {
              echo "âŒ Help output validation failed"
              exit 1
            }

            echo "âœ“ Binary execution tests passed"
          else
            echo "â­ Skipping execution tests for ${{ matrix.goos }}-${{ matrix.goarch }} (cross-compiled)"
          fi

          echo "âœ“ All smoke tests passed for ${{ matrix.goos }}-${{ matrix.goarch }}"

      - name: Generate checksums
        run: |
          sha256sum "${{ env.archive }}" > "${{ env.archive }}.sha256"

      - name: Upload release asset
        uses: actions/upload-release-asset@v1
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        with:
          upload_url: ${{ needs.create-release.outputs.upload_url }}
          asset_path: ./${{ env.archive }}
          asset_name: ${{ env.archive }}
          asset_content_type: application/octet-stream

      - name: Upload checksum
        uses: actions/upload-release-asset@v1
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        with:
          upload_url: ${{ needs.create-release.outputs.upload_url }}
          asset_path: ./${{ env.archive }}.sha256
          asset_name: ${{ env.archive }}.sha256
          asset_content_type: text/plain
